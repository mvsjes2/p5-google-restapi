#!/usr/bin/env perl

# Generates README.md from the POD in lib/Google/RestApi.pm.
# The POD is the single source of truth; run this after editing the POD
# to keep them in sync.
#
# Usage: bin/pod2readme

use strict;
use warnings;

use FindBin;
use File::Spec;

my $pm_file = File::Spec->catfile($FindBin::RealBin, '..', 'lib', 'Google', 'RestApi.pm');
my $readme  = File::Spec->catfile($FindBin::RealBin, '..', 'README.md');

# Read POD from the .pm file (everything after __END__).
open my $in, '<', $pm_file or die "Cannot read $pm_file: $!\n";
my $in_pod = 0;
my @pod_lines;
while (my $line = <$in>) {
  chomp $line;
  if ($line =~ /^__END__$/) {
    $in_pod = 1;
    next;
  }
  push @pod_lines, $line if $in_pod;
}
close $in;

die "No __END__ / POD section found in $pm_file\n" unless @pod_lines;

# Parse into sections keyed by =head1.
my @sections;
my $current;
for my $line (@pod_lines) {
  if ($line =~ /^=head1\s+(.+)/) {
    push @sections, $current if $current;
    $current = { title => $1, body => [] };
    next;
  }
  push @{ $current->{body} }, $line if $current;
}
push @sections, $current if $current;

# Sections to omit from the README (CPAN-only detail).
my %skip = (SUBROUTINES => 1);

# Convert POD inline formatting to Markdown.
sub pod2md {
  my $text = shift;
  $text =~ s/L<\/([^>]+)>/$1/g;   # L</Section>  -> Section
  $text =~ s/L<([^>]+)>/$1/g;     # L<Module>    -> Module
  $text =~ s/C<([^>]+)>/$1/g;     # C<code>      -> code
  return $text;
}

# Build the Markdown output.
my @out;
for my $section (@sections) {
  next if $skip{ $section->{title} };

  push @out, "# $section->{title}", '';

  my @body = @{ $section->{body} };

  if ($section->{title} eq 'SYNOPSIS') {
    for my $line (@body) {
      next if $line =~ /^=(over|back|cut)/;
      if ($line =~ /^(\s{2,})(.*)/) {
        # Verbatim code — blockquote with 5-space indent.
        my $code = $2;
        push @out, ">     $code";
      } elsif ($line =~ /^\s*$/) {
        push @out, '>';
      } else {
        # Plain text within the synopsis.
        push @out, pod2md($line);
      }
    }
    push @out, '';
    next;
  }

  if ($section->{title} eq 'NAVIGATION') {
    for my $line (@body) {
      next if $line =~ /^=(over|back|cut)/;
      next if $line =~ /^\s*$/;
      if ($line =~ /^=item\s*\*?\s*L<([^>]+)>/) {
        push @out, "    $1";
      }
    }
    push @out, '';
    next;
  }

  if ($section->{title} eq 'AUTHORS') {
    for my $line (@body) {
      next if $line =~ /^=(over|back|cut)/;
      next if $line =~ /^=item\s*$/;
      next if $line =~ /^\s*$/;
      push @out, '- ' . pod2md($line);
    }
    push @out, '';
    next;
  }

  # Generic section (DESCRIPTION, STATUS, COPYRIGHT, …).
  for my $line (@body) {
    next if $line =~ /^=(over|back|cut)/;
    if ($line =~ /^=item\s*\*?\s*(.*)/) {
      my $item = pod2md($1);
      push @out, "- $item" if $item =~ /\S/;
    } elsif ($line =~ /^\s*$/) {
      push @out, '';
    } else {
      push @out, pod2md($line);
    }
  }
  push @out, '';
}

# Collapse runs of blank lines to a single blank line.
my $md = join("\n", @out) . "\n";
$md =~ s/\n{3,}/\n\n/g;

open my $out_fh, '>', $readme or die "Cannot write $readme: $!\n";
print $out_fh $md;
close $out_fh;

print "Generated $readme from $pm_file\n";
